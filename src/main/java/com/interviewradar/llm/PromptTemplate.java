package com.interviewradar.llm;

public enum PromptTemplate {

    // 1. 问题抽取模板
    QUESTION_EXTRACTION("""
            你是“面试官提问抽取专家”。 \s
            输入：一段面经原文，可能含面试官提问、面试者回答、自述感受、流程说明、寒暄等。 \s
            任务：**只抽取真正的“面试官提问”**，输出 JSON：
            
            {
              "questions": [
                "问题1",
                "问题2",
                …
              ]
            }
            
            提取规则：
            1. **只保留开放式或命令式提问**，如“解释…”、“如何设计…”、“请…”； \s
            2. **剔除所有非技术性或无实质内容的陈述**，包括： \s
               - 面试者感受／情绪（“紧张得要死”） \s
               - 流程说明／安排（“后三轮由 HR 进行”） \s
               - 纯个人背景或待遇询问（“自我介绍”、“你家乡在哪？”、“薪资能接受多少？”） \s
               - 寒暄、废话、啰嗦修饰（“很简单啦”、“巴拉巴拉”） \s
            3. **合并 & 清理**： \s
               - 将语义相关的多条子问题合并为一句（如“线程池参数”“拒绝策略”→“线程池参数与拒绝策略”） \s
               - 删除口语冗词，仅保留核心关键词和逻辑 \s
            4. **严格输出**： \s
               - 仅返回上述 JSON，不要编号、不要问号、不要多余字段或说明 \s
               - 保持中文原句式，必要时补全“请”字
            
            示例 \s
            正例（应提取）：
            - 解释哈希表的实现原理与时间复杂度 \s
            - 如何手写二叉树的中序/前序/后序遍历 \s
            - 设计一个支持并发读写的缓存系统 \s
            - 讲解 Java 内存模型及其与多线程的关系 \s
            - 描述数据库索引的种类及其工作原理 \s
            - 什么是死锁？如何检测并解决死锁问题？ \s
            - CAP 理论是什么？在分布式系统中如何权衡？ \s
            - 解释 TCP 三次握手与四次挥手的完整流程 \s
            - 如何实现对高并发场景友好的消息队列？ \s
            - 请实现线程安全的单例模式并说明要点 \s
            
            负例（不应提取）：
            - 我感觉这家公司氛围很好 \s
            - 面试者：我准备了很久才来这里 \s
            - 安排一下后续面试流程吧 \s
            - 最后有其他问题吗？（HR 反问，不是技术提问） \s
            - 你家乡在哪里？你接受加班吗？ \s
            - 这个问题很简单，你能回答一下吗？ \s
            
            现在，请根据以上规则和示例，处理下面这段面经原文，直接返回仅含 `questions` 数组的 JSON： \s
            {{rawInterview}}
    """),

    // 2. 问题分类模板
    QUESTION_CLASSIFICATION("""
你是一个面试题分类助手，擅长根据题意从指定分类中找出最匹配的分类编号（可多选）。

请对下面共 ${n} 条面试题逐一分析，从下方“分类列表”中为每道题选择最贴切的分类编号。你只需返回一个 JSON 数组，每一项包含该题的序号和匹配的分类编号列表。

输出格式要求（必须严格遵守）：
[
  {"index":1,"categories":[分类编号A, 分类编号B]},
  {"index":2,"categories":[分类编号C]},
  ...
]

🔹说明：
- `index` 表示问题在列表中的序号，从 1 开始。
- `categories` 为选中的分类编号列表，至少一个，可多选。
- 不要输出任何解释、备注或多余文字，仅返回 JSON。

分类列表（编号 → 名称（说明））：
${categories}

面试题列表：
1.{questionText1}
2.{questionText2}
…
N.{questionTextN}
    """),

    // 3. 批量标准化提取问题模板
    QUESTION_STANDARDIZATION("""
            你是一个面试题标准化专家。
            
            请将下面这批原始面试问题，标准化为统一、干净、可归档的知识点标题，并严格遵守以下规则：
            
            ---
            
            ### 📌 标准化规则：
            
            1. **去除问法句式**：删除“什么是”、“请介绍”、“请说一下”、“如何”、“你能否讲讲”等开头；
            2. **去除语气表达**：删除“请”、“能否”、“吗”、“呢”、“？”等语气词及标点；
            3. **保留核心术语**：准确提取问题中的核心技术关键词或术语；
            4. **对比类统一格式**：凡涉及对比类问题，一律转化为“X 和 Y 的区别”；
            5. **允许的后缀词**：可根据语义补充后缀，如：概述 / 原理 / 实现 / 区别 / 用途 / 流程；
            6. **禁止生成多余内容**：不要添加解释、注释或与原意无关的新内容；
            7. **输出格式**：输出严格为 JSON 数组对象列表，每个对象包含 index 与 titles 两部分；
            8. **顺序一致**：输出顺序必须与输入问题列表一致；
            9. **语言风格统一**：标题应使用简洁书面语，避免口语化；
            10. **复合问题拆分**：若一句话中包含多个问题（如“X 的作用和原理”），请拆分为多个标题，每个标题聚焦一个独立知识点；
            11. **去除模糊修饰词**：如“常见的”、“一般的”、“主要的”等修饰词，除非确有必要，请省略；
            12. 对于含有**重要约束条件**（如数据规模、内存限制、并发条件、延迟要求等）的问题，不得省略这些限制性信息，需保留在标准化标题中，以保证语义完整；
            13. **补全缺失上下文信息**：若原问题中某一部分的术语或指代依赖上下文（如“等待 2MSL”依赖 TCP 握手语境），在拆分为独立标题时必须补全缺失上下文，确保每个标题在脱离原句的情况下仍能被准确理解。
            ---
            
            ### ✅ 示例输入格式：
            
            面试原问题列表： \s
            1. 什么是线程池？ \s
            2. 请介绍 GC 的几种算法 \s
            3. HashMap 和 ConcurrentHashMap 区别？ \s
            4. 如何实现 LRU 缓存？ \s
            5. 你在项目中负责的模块有哪些？ \s
            6. 说一下线程池的作用和实现原理 \s
            7. 常见的负载均衡算法有哪些？ \s
            8. Redis 缓存穿透怎么解决？穿透和雪崩的区别是什么？ \s
            9. 能否讲讲分布式系统中的一致性问题？ \s
            10. 什么情况下会用到消息队列？ \s
            11. 你做过哪些常见的系统优化？ \s
            12. Kafka 有哪些常用命令？ \s
            13. 请说一下数据库事务的四大特性 \s
            14. MySQL 和 PostgreSQL 的区别？ \s
            15. 什么是 Spring AOP？AOP 有哪些典型应用场景？ \s
            16. Kubernetes 的核心组件和其职责？ \s
            17. 简述 Java 中的反射机制及其应用 \s
            18. 你了解哪些常见的安全漏洞？ \s
            19. 你觉得项目中最难解决的问题是什么？ \s
            20. 如何对 1 亿条数据进行排序，内存限制为 10M \s
            21. 解释第四次挥手的必要性及等待2MSL的原因 
            ---
            
            ### ✅ 输出格式要求（必须严格遵守）：
            
            ```json
            [
              {"index":1, "titles":["线程池概述"]},
              {"index":2, "titles":["GC 的几种算法"]},
              {"index":3, "titles":["HashMap 和 ConcurrentHashMap 的区别"]},
              {"index":4, "titles":["LRU 缓存实现"]},
              {"index":5, "titles":["项目负责模块"]},
              {"index":6, "titles":["线程池的作用", "线程池的实现原理"]},
              {"index":7, "titles":["负载均衡算法"]},
              {"index":8, "titles":["Redis 缓存穿透解决方案", "缓存穿透和缓存雪崩的区别"]},
              {"index":9, "titles":["分布式系统一致性问题"]},
              {"index":10, "titles":["消息队列使用场景"]},
              {"index":11, "titles":["系统优化内容"]},
              {"index":12, "titles":["Kafka 常用命令"]},
              {"index":13, "titles":["数据库事务的四大特性"]},
              {"index":14, "titles":["MySQL 和 PostgreSQL 的区别"]},
              {"index":15, "titles":["Spring AOP 概述", "AOP 应用场景"]},
              {"index":16, "titles":["Kubernetes 核心组件", "Kubernetes 各组件职责"]},
              {"index":17, "titles":["Java 反射机制概述", "Java 反射机制应用"]},
              {"index":18, "titles":["常见安全漏洞"]},
              {"index":19, "titles":[]},
              {"index":20, "titles":["内存受限场景下大规模数据排序实现"]},
              {"index":21, "titles":["TCP 第四次挥手的必要性", "TCP 中等待 2MSL 的原因"]}
            ]
            请根据上述规则，对下面的${n}道面试原问题列表进行标准化处理，并严格使用 JSON 格式返回结果。
            面试原问题列表：
            ${questions}
    """),


    // 3. 知识点抽取模板
    KNOWLEDGE_EXTRACTION("""
      你是一个面试题知识点抽取助手。
      给定一条已分类的面试问题，请结合其分类上下文，从已有知识点库中提取相关知识点名称。
      如果提取的知识点不在已有库中，也请输出。

      问题文本：
      {questionText}
      已选分类：{categoryName}

      输出格式为 JSON 数组，例如 ["事务隔离级别", "MVCC"]。
    """),

    ;

    private final String template;
    PromptTemplate(String template) { this.template = template; }
    public String getTemplate() { return template; }
}
