package com.interviewradar.llm;

import lombok.Getter;

@Getter
public enum PromptTemplate {

    // 1. 问题抽取模板
    QUESTION_EXTRACTION("""
    你是“面试官提问抽取专家”。 \s
    输入：一段面经原文，可能含面试官提问、面试者回答、自述感受、流程说明、寒暄等。 \s
    任务：**只抽取真正的“面试官提问”**，输出 JSON：
    
    {
      "questions": [
        "问题1",
        "问题2",
        …
      ]
    }
    
    提取规则：
    1. **只保留开放式或命令式提问**，如“解释…”、“如何设计…”、“请…”； \s
    2. **剔除所有非技术性或无实质内容的陈述**，包括： \s
       - 面试者感受／情绪（“紧张得要死”） \s
       - 流程说明／安排（“后三轮由 HR 进行”） \s
       - 纯个人背景或待遇询问（“自我介绍”、“你家乡在哪？”、“薪资能接受多少？”） \s
       - 寒暄、废话、啰嗦修饰（“很简单啦”、“巴拉巴拉”） \s
    3. **合并 & 清理**： \s
       - 将语义相关的多条子问题合并为一句（如“线程池参数”“拒绝策略”→“线程池参数与拒绝策略”） \s
       - 删除口语冗词，仅保留核心关键词和逻辑 \s
    4. **严格输出**： \s
       - 仅返回上述 JSON，不要编号、不要问号、不要多余字段或说明 \s
       - 保持中文原句式，必要时补全“请”字
    
    示例 \s
    正例（应提取）：
    - 解释哈希表的实现原理与时间复杂度 \s
    - 如何手写二叉树的中序/前序/后序遍历 \s
    - 设计一个支持并发读写的缓存系统 \s
    - 讲解 Java 内存模型及其与多线程的关系 \s
    - 描述数据库索引的种类及其工作原理 \s
    - 什么是死锁？如何检测并解决死锁问题？ \s
    - CAP 理论是什么？在分布式系统中如何权衡？ \s
    - 解释 TCP 三次握手与四次挥手的完整流程 \s
    - 如何实现对高并发场景友好的消息队列？ \s
    - 请实现线程安全的单例模式并说明要点 \s
    
    负例（不应提取）：
    - 我感觉这家公司氛围很好 \s
    - 面试者：我准备了很久才来这里 \s
    - 安排一下后续面试流程吧 \s
    - 最后有其他问题吗？（HR 反问，不是技术提问） \s
    - 你家乡在哪里？你接受加班吗？ \s
    - 这个问题很简单，你能回答一下吗？ \s
    
    现在，请根据以上规则和示例，处理下面这段面经原文，直接返回仅含 `questions` 数组的 JSON： \s
    {{rawInterview}}
    """),

    // 2. 问题分类模板
    QUESTION_CLASSIFICATION("""
    你是一个面试题分类助手，擅长根据题意从指定分类中找出最匹配的分类编号（可多选）。
    
    请对下面共 ${n} 条面试题逐一分析，从下方“分类列表”中为每道题选择最贴切的分类编号。你只需返回一个 JSON 数组，每一项包含该题的序号和匹配的分类编号列表。
    
    输出格式要求（必须严格遵守）：
    [
      {"index":1,"categories":[分类编号A, 分类编号B]},
      {"index":2,"categories":[分类编号C]},
      ...
    ]
    
    🔹说明：
    - `index` 表示问题在列表中的序号，从 1 开始。
    - `categories` 为选中的分类编号列表，至少一个，可多选。
    - 不要输出任何解释、备注或多余文字，仅返回 JSON。
    
    分类列表（编号 → 名称（说明））：
    ${categories}
    
    面试题列表：
    1.{questionText1}
    2.{questionText2}
    …
    N.{questionTextN}
    """),

    // 3. 批量标准化提取问题模板
    QUESTION_STANDARDIZATION("""
    你是一个面试题标准化专家。
    
    请将下面这批原始面试问题，标准化为统一、干净、可归档的知识点标题，并严格遵守以下规则：
    
    ---
    
    ### 📌 标准化规则：
    
    1. **去除问法句式**：删除“什么是”、“请介绍”、“请说一下”、“如何”、“你能否讲讲”等开头；
    2. **去除语气表达**：删除“请”、“能否”、“吗”、“呢”、“？”等语气词及标点；
    3. **保留核心术语**：准确提取问题中的核心技术关键词或术语；
    4. **对比类统一格式**：凡涉及对比类问题，一律转化为“X 和 Y 的区别”；
    5. **允许的后缀词**：可根据语义补充后缀，如：概述 / 原理 / 实现 / 区别 / 用途 / 流程；
    6. **禁止生成多余内容**：不要添加解释、注释或与原意无关的新内容；
    7. **输出格式**：输出严格为 JSON 数组对象列表，每个对象包含 index 与 titles 两部分；
    8. **顺序一致**：输出顺序必须与输入问题列表一致；
    9. **语言风格统一**：标题应使用简洁书面语，避免口语化；
    10. **复合问题拆分**：若一句话中包含多个问题（如“X 的作用和原理”），请拆分为多个标题，每个标题聚焦一个独立知识点；
    11. **去除模糊修饰词**：如“常见的”、“一般的”、“主要的”等修饰词，除非确有必要，请省略；
    12. 对于含有**重要约束条件**（如数据规模、内存限制、并发条件、延迟要求等）的问题，不得省略这些限制性信息，需保留在标准化标题中，以保证语义完整；
    13. **补全缺失上下文信息**：若原问题中某一部分的术语或指代依赖上下文（如“等待 2MSL”依赖 TCP 握手语境），在拆分为独立标题时必须补全缺失上下文，确保每个标题在脱离原句的情况下仍能被准确理解。
    ---
    
    ### ✅ 示例输入格式：
    
    面试原问题列表： \s
    1. 什么是线程池？ \s
    2. 请介绍 GC 的几种算法 \s
    3. HashMap 和 ConcurrentHashMap 区别？ \s
    4. 如何实现 LRU 缓存？ \s
    5. 你在项目中负责的模块有哪些？ \s
    6. 说一下线程池的作用和实现原理 \s
    7. 常见的负载均衡算法有哪些？ \s
    8. Redis 缓存穿透怎么解决？穿透和雪崩的区别是什么？ \s
    9. 能否讲讲分布式系统中的一致性问题？ \s
    10. 什么情况下会用到消息队列？ \s
    11. 你做过哪些常见的系统优化？ \s
    12. Kafka 有哪些常用命令？ \s
    13. 请说一下数据库事务的四大特性 \s
    14. MySQL 和 PostgreSQL 的区别？ \s
    15. 什么是 Spring AOP？AOP 有哪些典型应用场景？ \s
    16. Kubernetes 的核心组件和其职责？ \s
    17. 简述 Java 中的反射机制及其应用 \s
    18. 你了解哪些常见的安全漏洞？ \s
    19. 你觉得项目中最难解决的问题是什么？ \s
    20. 如何对 1 亿条数据进行排序，内存限制为 10M \s
    21. 解释第四次挥手的必要性及等待2MSL的原因 
    ---
    
    ### ✅ 输出格式要求（必须严格遵守）：
    
    ```json
    [
      {"index":1, "titles":["线程池概述"]},
      {"index":2, "titles":["GC 的几种算法"]},
      {"index":3, "titles":["HashMap 和 ConcurrentHashMap 的区别"]},
      {"index":4, "titles":["LRU 缓存实现"]},
      {"index":5, "titles":["项目负责模块"]},
      {"index":6, "titles":["线程池的作用", "线程池的实现原理"]},
      {"index":7, "titles":["负载均衡算法"]},
      {"index":8, "titles":["Redis 缓存穿透解决方案", "缓存穿透和缓存雪崩的区别"]},
      {"index":9, "titles":["分布式系统一致性问题"]},
      {"index":10, "titles":["消息队列使用场景"]},
      {"index":11, "titles":["系统优化内容"]},
      {"index":12, "titles":["Kafka 常用命令"]},
      {"index":13, "titles":["数据库事务的四大特性"]},
      {"index":14, "titles":["MySQL 和 PostgreSQL 的区别"]},
      {"index":15, "titles":["Spring AOP 概述", "AOP 应用场景"]},
      {"index":16, "titles":["Kubernetes 核心组件", "Kubernetes 各组件职责"]},
      {"index":17, "titles":["Java 反射机制概述", "Java 反射机制应用"]},
      {"index":18, "titles":["常见安全漏洞"]},
      {"index":19, "titles":[]},
      {"index":20, "titles":["内存受限场景下大规模数据排序实现"]},
      {"index":21, "titles":["TCP 第四次挥手的必要性", "TCP 中等待 2MSL 的原因"]}
    ]
    请根据上述规则，对下面的${n}道面试原问题列表进行标准化处理，并严格使用 JSON 格式返回结果。
    面试原问题列表：
    ${questions}
    """),

    CANDIDATE_DECISION("""
    你是“标准问题决策助手”（Standard Question Decision Assistant），你的职责是：
    1. 将面试中出现的问题与数据库中已有标准问法进行语义比对，确保数据库中标准问法的统一性和可复用性；
    2. 通过判断复用已有标准问法、创建新标准问法或跳过无效问法，保持问法标准化，提升知识库质量。
    
    为什么要这样做：
    1. 统一管理：避免问法重复与异构，提高检索与维护效率； \s
    2. 知识复用：充分利用已有高质量标准问法，减少冗余； \s
    3. 保证质量：过滤噪声或无意义问法，确保知识库干净、有用。
    
    使用流程 \s
    1. 接收一个面试中出现的问题：question； \s
    2. 获取相似标准问法列表，每条格式为 `序号. “文本” (Id = 数据库Id)`，例如 \s
    “线程池关闭方法” (Id=42)
    “线程池创建模式” (Id=37)
    3. 根据以下判断逻辑输出决策。
    决策规则： \s
    - REUSE：若候选问法与某条标准问法在含义上完全一致（即问的是同一件事）或者被包含于某条标准问法，则复用该标准问法： \s
    { "action": "REUSE", "chosenId": <该标准问法的数据库 Id> }
    - CREATE：若无任何完全一致，但候选问法有实际意义且列表中未覆盖，则创建新标准问法：
    { "action": "CREATE", "newStandard": "question原文" }
    - SKIP：若候选问法为噪声、无意义或无关，则跳过：
    { "action": "SKIP", "skipReason":"选择SKIP的原因，可以自己写合适的原因" }
    
    严格要求
    1.仅输出上述 JSON，禁止任何额外文字、注释或格式；
    2.确保返回合法的 JSON。
    
    示例1：
    question: “TCP 三次握手”
    standards:
    1. “TCP 三次握手过程” (Id=42)
    2. “TCP 四次挥手过程” (Id=37)
    3. “TCP 第三次握手的必要性” (Id=65)
    输出：
    { "action": "REUSE", "chosenId": 42 }
    
    示例2：
    question: “Java 基础”
    standards:
    1. “Java 内存模型概述” (Id=15)
    2. “Java 基本数据类型和包装类” (Id=151)
    3. “Java 常用集合” (Id=151)
    输出：
    { "action": "SKIP", "skipReason": "问题太宽泛" }
    
    示例3：
    question: “热部署原理”
    standards:
    1. “双亲委派模型原理” (Id=60)
    2. “JVM 调优工具” (Id=66)
    3. “分布式日志管理” (Id=99)
    4. “死锁概述” (Id=85)
    输出：
    { "action": "CREATE", "newStandard": "热部署原理" }
    
    示例4：
    question: “缓存击穿”
    standards:
    1. “缓存击穿 缓存雪崩 缓存穿透” (Id=160)
    2. “分布式追踪” (Id=266)
    3. “ConcurrentHashMap 概述” (Id=399)
    输出：
    { "action": "REUSE", "chosenId": "160" }
    
    现在，请根据上述规则，处理下面内容，并严格返回 JSON：
    面试中的问题：
    ${question}
    
    相似标准问法列表：
    ${standards}
    """)
    ;

    private final String template;
    PromptTemplate(String template) { this.template = template; }
}
